Great! I’ll refactor the Redux + redux-observable architecture to use Zustand for UI state, React Query + Axios for async server state, with:

switchMap-like cancellation logic for LOAD_TODOS and LOAD_TODO_ITEM using AbortController and React Query’s cancellation support.

mergeMap-like parallel processing for ADD_TODO and DELETE_TODO using standard useMutation.

I’ll use the versions from your provided package.json and preserve the modular folder structure. I’ll let you know when the refactor is ready for review.

Research completed in 11m · 4 sources
Refactored Todo Architecture: Zustand & React Query
In this refactoring, we replace Redux + redux-observable with Zustand for local UI state and React Query + Axios for server state. This approach cleanly separates concerns: React Query handles server-cached data (todos from Firebase) while Zustand manages UI state (e.g. selected item)​
CHAMITH.MEDIUM.COM
. We mimic the original RxJS behaviors as follows:
switchMap-like cancellation: React Query provides an AbortSignal to each query function​
TANSTACK.COM
. By passing this signal to Axios (supported in v0.22+​
STACKOVERFLOW.COM
), any previous in-flight request for Load Todos or Load Todo Item is automatically aborted when a new one starts (only the latest result is used, just like switchMap).
mergeMap-like parallelism: For Add Todo and Delete Todo, we use useMutation so multiple requests can run concurrently. Each call is independent (no cancellation of previous mutations), matching mergeMap behavior (parallel processing).
We maintain the modular structure (features/todos/, shared/models/, SCSS modules for styling) and use the specified versions (Vite, React 19, TypeScript 5.7.2, Zustand 5.0.3, React Query 5.71.5, Axios 1.8.4). Below is the full implementation, file by file:
shared/models/todo.ts
Define the Todo data model. We include an id (Firebase key), a title, and a completed flag for completeness:
ts
Copy
Edit
// shared/models/todo.ts
export interface Todo {
  id: string;
  title: string;
  completed: boolean;
}
features/todos/api.ts
This module implements all server interactions using Axios and React Query hooks:
Axios setup: We configure a base URL for the Firebase Realtime Database. All requests append .json as required by Firebase's REST API.
Data fetch functions: fetchTodos and fetchTodo use axios.get with signal for cancellation. They transform Firebase's response (which is an object map) into our Todo structures.
Mutations: addTodo (uses axios.post) and deleteTodo (axios.delete) handle creating and removing todos.
React Query hooks: useTodosQuery and useTodoItemQuery wrap useQuery. They utilize the abort signal to cancel stale requests (ensuring only the latest fetch is used, as with switchMap). useTodoItemQuery is disabled when no ID is selected. For mutations, useAddTodoMutation and useDeleteTodoMutation use useMutation and on success, invalidate the todos query to refresh the list. Multiple mutations can run in parallel (mergeMap behavior).
ts
Copy
Edit
// features/todos/api.ts
import axios from 'axios';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import type { Todo } from '../../shared/models/todo';

// Axios instance for Firebase REST API
const api = axios.create({
  baseURL: 'https://react-architecture-todo-default-rtdb.firebaseio.com',
});

// Data shape from Firebase (without the id, which is the key)
type TodoData = Omit<Todo, 'id'>;

/** Fetch all todos (GET). Uses AbortSignal for cancellation (switchMap behavior). */
const fetchTodos = async ({ signal }: { signal?: AbortSignal }): Promise<Todo[]> => {
  const response = await api.get<Record<string, TodoData> | null>('/todos.json', { signal });
  const data = response.data;
  if (!data) {
    return []; // no todos
  }
  // Transform { key: {title, completed}, ... } into Todo[]
  return Object.entries(data).map(([id, todo]) => ({ id, ...todo }));
};

/** Fetch a single todo by ID (GET). Aborted if query becomes outdated. */
const fetchTodo = async (id: string, signal?: AbortSignal): Promise<Todo> => {
  const response = await api.get<TodoData | null>(`/todos/${id}.json`, { signal });
  const data = response.data;
  if (!data) {
    throw new Error('Todo not found');
  }
  return { id, ...data };
};

/** Add a new todo (POST). Returns the created Todo (with generated ID). */
const addTodo = async (newTodo: Omit<Todo, 'id'>): Promise<Todo> => {
  const response = await api.post<{ name: string }>(`/todos.json`, newTodo);
  const { name: id } = response.data;  // Firebase returns the new record's key as "name"
  return { id, ...newTodo };
};

/** Delete a todo by ID (DELETE). */
const deleteTodo = async (id: string): Promise<void> => {
  await api.delete(`/todos/${id}.json`);
  // No data returned on delete; just resolve if successful.
};

// React Query Hooks:

/** useTodosQuery: fetches the todo list, cancels previous fetch if a new one starts. */
export function useTodosQuery() {
  return useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,  // React Query will pass { signal } to fetchTodos
    // staleTime, refetchOnWindowFocus, etc., can be configured as needed
  });
}

/** useTodoItemQuery: fetches a single todo item by ID. Cancels any prior fetch if ID changes. */
export function useTodoItemQuery(todoId: string | null) {
  return useQuery({
    queryKey: ['todo', todoId],
    enabled: !!todoId,             // only run when an ID is provided
    queryFn: ({ signal }) => {
      // If called without an ID (shouldn't happen due to enabled flag), throw:
      if (!todoId) throw new Error('No todo ID provided');
      return fetchTodo(todoId, signal);
    },
    // The AbortSignal (signal) ensures that if todoId changes (previous query becomes unused),
    // the previous request is aborted&#8203;:contentReference[oaicite:3]{index=3}.
  });
}

/** useAddTodoMutation: posts a new todo. Multiple calls are allowed concurrently. */
export function useAddTodoMutation() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: addTodo,
    onSuccess: () => {
      // After adding, refresh the todos list (parallel requests won't cancel each other)
      queryClient.invalidateQueries(['todos']);
    },
  });
}

/** useDeleteTodoMutation: deletes a todo by ID. Allows concurrent deletions. */
export function useDeleteTodoMutation() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: deleteTodo,
    onSuccess: () => {
      // Invalidate todos list to refetch updated data
      queryClient.invalidateQueries(['todos']);
    },
  });
}
Note: The signal passed to Axios ensures that if a query is no longer needed (e.g. component unmounts or key changes), the HTTP request is aborted​
STACKOVERFLOW.COM
. This mirrors the switchMap cancellation from redux-observable. Meanwhile, useMutation does not cancel ongoing calls, so multiple addTodo or deleteTodo operations can happen in parallel (like mergeMap).
features/todos/store.ts
The Zustand store holds UI state that is not part of the remote data. In this case, we track a selectedTodoId (e.g. the user’s selected item for viewing details or editing). You can extend this store with other UI flags (loading spinners, filters, etc.) as needed. Zustand provides a simple hook (useTodoUIStore) to get and set this state in components.
ts
Copy
Edit
// features/todos/store.ts
import { create } from 'zustand';

interface TodoUIState {
  selectedTodoId: string | null;
  setSelectedTodo: (id: string | null) => void;
}

export const useTodoUIStore = create<TodoUIState>((set) => ({
  selectedTodoId: null,
  setSelectedTodo: (id) => set({ selectedTodoId: id }),
}));
features/todos/TodoList.tsx
This React component displays the list of todos and allows selection and deletion. It uses the hooks defined above:
Load Todos: We call useTodosQuery() to fetch the list. React Query manages loading and error states (isLoading, error, etc.).
Delete Todo: We use useDeleteTodoMutation() and call mutate(id) when the delete button is clicked. Because we used mergeMap logic (no cancellation), multiple deletes can be triggered without waiting for each other.
Select Todo: Clicking on a list item will update the Zustand selectedTodoId. We also show a detail panel for the selected todo by using useTodoItemQuery(selectedTodoId). If the user rapidly selects different todos, the abort signal ensures only the latest detail fetch resolves (previous detail requests are canceled, achieving switchMap behavior for item loading).
We also import SCSS module styles for basic styling.
tsx
Copy
Edit
// features/todos/TodoList.tsx
import React from 'react';
import { useTodosQuery, useDeleteTodoMutation, useTodoItemQuery } from './api';
import { useTodoUIStore } from './store';
import styles from './TodoList.module.scss';

const TodoList: React.FC = () => {
  // Fetch todos list (data is cached and kept in React Query state)
  const {
    data: todos,
    isLoading: isListLoading,
    isError: isListError,
    error: listError,
  } = useTodosQuery();

  // Prepare delete mutation
  const deleteMutation = useDeleteTodoMutation();

  // Zustand state for selected todo
  const selectedTodoId = useTodoUIStore((state) => state.selectedTodoId);
  const setSelectedTodo = useTodoUIStore((state) => state.setSelectedTodo);

  // Fetch selected todo details (will auto-cancel previous fetch if selectedTodoId changes)
  const {
    data: selectedTodo,
    isLoading: isDetailLoading,
    isError: isDetailError,
    error: detailError,
  } = useTodoItemQuery(selectedTodoId);

  // Handlers
  const handleSelect = (id: string) => {
    setSelectedTodo(id);
  };
  const handleDelete = (id: string, e: React.MouseEvent) => {
    e.stopPropagation(); // prevent selecting while deleting
    deleteMutation.mutate(id);
  };

  if (isListLoading) {
    return <p>Loading todos...</p>;
  }
  if (isListError) {
    return <p>Error loading todos: {String(listError)}</p>;
  }

  return (
    <div className={styles.container}>
      <h2>Todo List</h2>
      <ul className={styles.list}>
        {todos?.map((todo) => (
          <li
            key={todo.id}
            onClick={() => handleSelect(todo.id)}
            className={`${styles.todoItem} ${todo.id === selectedTodoId ? styles.selected : ''}`}
          >
            <span>{todo.title}</span>
            <button
              className={styles.deleteBtn}
              onClick={(e) => handleDelete(todo.id, e)}
            >
              Delete
            </button>
          </li>
        ))}
      </ul>

      {/* Detail panel for selected todo (if any) */}
      {selectedTodoId && (
        <div className={styles.detailPanel}>
          {isDetailLoading && <p>Loading details...</p>}
          {isDetailError && <p>Error loading todo: {String(detailError)}</p>}
          {selectedTodo && (
            <div>
              <h3>Todo Details</h3>
              <p><strong>ID:</strong> {selectedTodo.id}</p>
              <p><strong>Title:</strong> {selectedTodo.title}</p>
              <p><strong>Completed:</strong> {selectedTodo.completed ? 'Yes' : 'No'}</p>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default TodoList;
features/todos/AddTodoForm.tsx
This component provides a form to add a new todo. It uses useAddTodoMutation() to handle the submission:
We manage the input text in local component state.
On form submit, call addTodoMutation.mutate. We pass the new todo data (here just a title and default completed: false). The mutation’s onSuccess (defined in api.ts) will invalidate the todo list query, triggering a refresh. We also reset the input field on success.
While the add is in progress, we disable the form and show a loading indicator on the button. Any number of adds can be triggered in parallel; each will create a separate request (no cancellations of other adds).
tsx
Copy
Edit
// features/todos/AddTodoForm.tsx
import React, { useState } from 'react';
import { useAddTodoMutation } from './api';
import styles from './AddTodoForm.module.scss';

const AddTodoForm: React.FC = () => {
  const [title, setTitle] = useState('');
  const addTodoMutation = useAddTodoMutation();

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    const trimmed = title.trim();
    if (!trimmed) return;
    // Trigger addTodo mutation
    addTodoMutation.mutate(
      { title: trimmed, completed: false },
      {
        onSuccess: () => {
          setTitle(''); // clear input on success
        }
      }
    );
  };

  return (
    <form onSubmit={handleSubmit} className={styles.form}>
      <input
        className={styles.input}
        type="text"
        placeholder="New todo..."
        value={title}
        onChange={(e) => setTitle(e.target.value)}
        disabled={addTodoMutation.isLoading}
      />
      <button type="submit" className={styles.addButton} disabled={addTodoMutation.isLoading}>
        {addTodoMutation.isLoading ? 'Adding...' : 'Add Todo'}
      </button>
      {addTodoMutation.isError && (
        <p className={styles.error}>
          Error: {String(addTodoMutation.error)}
        </p>
      )}
    </form>
  );
};

export default AddTodoForm;
features/todos/TodoList.module.scss
We use SCSS modules for component-specific styling. These class names are referenced in the JSX via the imported styles object. (The content below is an example; you can adjust styles as needed.)
scss
Copy
Edit
/* features/todos/TodoList.module.scss */
.container {
  padding: 1rem;
}
.list {
  list-style: none;
  padding: 0;
  margin: 0;
}
.todoItem {
  display: flex;
  justify-content: space-between;
  padding: 0.5em;
  border-bottom: 1px solid #ccc;
  cursor: pointer;
}
.todoItem:hover {
  background: #f9f9f9;
}
.selected {
  background: #e0f7ff;
}
.deleteBtn {
  margin-left: 1em;
}
.detailPanel {
  margin-top: 1em;
  padding: 1em;
  border: 1px solid #ddd;
  background: #fcfcfc;
}
features/todos/AddTodoForm.module.scss
Styles for the add-todo form:
scss
Copy
Edit
/* features/todos/AddTodoForm.module.scss */
.form {
  margin-top: 1em;
  display: flex;
  gap: 0.5em;
}
.input {
  flex: 1;
  padding: 0.5em;
  font-size: 1rem;
}
.addButton {
  padding: 0.5em 1em;
  font-size: 1rem;
}
.addButton:disabled {
  opacity: 0.6;
}
.error {
  color: red;
  margin-top: 0.5em;
  font-size: 0.9rem;
}
App Integration
Finally, ensure your application is set up to use React Query and the new components:
Query Client Provider: Wrap your app with QueryClientProvider at the root (e.g. in main.tsx or App.tsx) so that React Query's context is available:
ts
Copy
Edit
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient();

// ... in your app's entry point:
<QueryClientProvider client={queryClient}>
  <App />
</QueryClientProvider>
Use the Todo components: In your App.tsx or relevant route, render the TodoList and AddTodoForm components (along with any other UI). For example:
tsx
Copy
Edit
import TodoList from './features/todos/TodoList';
import AddTodoForm from './features/todos/AddTodoForm';

function App() {
  return (
    <div>
      <TodoList />
      <AddTodoForm />
    </div>
  );
}
export default App;
With this refactoring, the application now uses Zustand for managing UI state (like the selected todo) and React Query + Axios for efficient data fetching, caching, and mutation. The behavior of switchMap vs mergeMap is preserved: list and detail loads will cancel stale requests on new triggers​
STACKOVERFLOW.COM
, and add/delete operations can proceed in parallel. This results in a simpler, more maintainable architecture that leverages modern state management best practices while fulfilling the original requirements.